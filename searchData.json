[{"title":"测试","url":"/2022/07/19/测试/","content":"html篇\n1.行内元素有哪些，块级元素有哪些，行内块级元素有哪些？\n答：行内元素：a span em strong b i u lable br\n    块级元素: div p ul ol lo dl dt dd h1-h6 form table\n    行内块元素: img input textarea button\n    区别：行内元素可以多个标签存在一行 对宽高属性值不生效，完全靠内容撑开宽高，块级元素独占一行，对宽高属性值生效，行内块元素对宽高生效，并且可以多个标签存在一行"},{"title":"四种数组循环方法区别","url":"/2021/12/28/四种数组循环方法区别/","content":"四种数组循环方法的区别\n\n一. 基础for循环 遍历数组\n\n```js\nlet list = [1, 2, 3, 5, 4, 6]\nfor (let i = 0, len = list.length; i < len; i++) {\n  console.log(list[i])  // 1,2,3,5,4,6\n}\n```\n\n\n\n二.forEach循环 遍历数组 \n\n​\tforEach循环我们可以直接取到元素，foreach不会改变数组，同时也可以取到index值。但是forEach也有一些局限，不能continue跳过或者break终止循环\n\n```js\nlet arr = ['a', 'b', 'c', 'd']\narr.forEach((val, index, arr) => {\n  console.log(`index:${index}, val: ${val}`)\n  console.log(val + 1) // a1, b1, c1, d1\n  console.log(arr) //['a', 'b', 'c', 'd']\n})\n\n/*\nindex:0, val: a\nindex:1, val: b\nindex:2, val: c\nindex:3, val: d\n*/\n```\n\n\n\n三.for in\n\n```js\nfor(var item in arr|obj){} 可以用于遍历数组和对象\n```\n　　遍历数组时，item表示索引值， arr表示当前索引值对应的元素 arr[item]\n　　遍历对象时，item表示key值，arr表示key值对应的value值 obj[item]\n　　for in一般循环遍历的都是对象的属性，遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性\n\n```js\nlet obj = { a: 1, b: 2, c: 3 }\n\nfor (let item in obj) {\n  console.log(`obj.${item} = ${obj[item]}`)\n}\n\n// obj.a = 1\n// obj.b = 2\n// obj.c = 3\n\nlet obj = ['a', 'b', 'c']\n\nfor (let item in obj) {\n  console.log(`obj.${item} = ${obj[item]}`)\n}\n\n// obj.0 = a\n// obj.1 = b\n// obj.2 = c\n```\n\n\n\n四. for of\n\n​\tES6中新增加的语法 for of 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 for of 循环，以替代 for in 和 forEach() ，并支持新的迭代协议。for of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。\n\n```js\n//循环一个数组:\nlet arr = ['a', 'b', 'c']\nfor (let val of arr) {\n  console.log(val)\n}\n\n// 循环一个字符串:\nlet str = 'abc'\nfor (let val of str) {\n  console.log(val) // a b c\n}\n\n//循环一个Map:\nlet iterable = new Map([[\"a\", 1], [\"b\", 2], [\"c\", 3]]);\nfor (let [key, value] of iterable) {\n  console.log(value, key);\n}\n//1 'a'\n//2 'b'\n//3 'c'\n\n//entry 只有一个值时遍历大的数组\nfor (let entry of iterable) {\n  console.log(entry);\n}\n// [a, 1]\n// [b, 2]\n// [c, 3]\n\n循环一个 Set:\nlet iterable = new Set([1, 1, 2, 2, 3, 3]);\nfor (let value of iterable) {\n　　console.log(value);\n}\n// 1\n// 2\n// 3\n```\n\n\n\n"},{"title":"数组方法","url":"/2021/12/24/数组方法/","content":"pop shift   数组删除操作 \n\npush unshift 数组添加操作\n\nsplice 添加新项  删除元素\n\nslice 切割数组  原数组不变\n\ntoString \n\nsort 结合 a-b 排序\n\nMath.max.apply 最大值\n\n```js\nfunction maxArray(arr) {\n\t\treturn Math.max.apply(null, arr)\n\t}\n```\n\nMath.min.apply 最小值\n\n```js\nfunction maxArray(arr) {\n\t\treturn Math.min.apply(null, arr)\n\t}\n```\n\nforEach 方法为每个数组元素调用一次函数（回调函数）\n\n```js\nlet arr2 = []\n\tarr.forEach((value) => {\n\t\tarr2 += value + 1\n\t})\nconsole.log(arr)\nconsole.log(arr2)\n```\n\n\n\nArray.map() \n\n通过对每个数组元素执行函数来创建新数组\n\n不会对没有值的数组元素执行函数\n\n方法不会更改原始数组\n\n```js\nlet arr3 = []\n\t\tarr3 = arr.map(myFc)\n\n\t\tfunction myFc(value, index, array) {\n\t\t\treturn value * 2\n\t\t}\n\t\tconsole.log(arr3) //(5) [2, 4, 6, 10, 8]\n```\n\n- 项目值\n- 项目索引\n- 数组本身\n\nfilter() 方法\n\n创建一个包含通过测试的数组元素的新数组\n\n```js\n\tlet arr = [1, 2, 3, 5, 4]\n\t\tlet arr2 = arr.filter(myFc)\n\n\t\tfunction myFc(value, index, array) {\n\t\t\treturn value > 2\n\t\t}\n\t\tconsole.log(arr2)// (3) [3, 5, 4]\n```\n\n请注意此函数接受 3 个参数：\n\n- 项目值\n- 项目索引\n- 数组本身\n\n\n\nreduce()\n\n在每个数组元素上运行函数，以生成（减少它）单个值\n\n在数组中从左到右工作 另请参阅 reduceRight()\n\n方法不会减少原始数组\n\n例子: 数组中所有数字的总和\n\n```js\nlet arr = [1, 2, 3, 5, 4]\n\t\tlet sum = arr.reduce(myFc)\n\n\t\tfunction myFc(totle, value) {\n\t\t\treturn totle + value\n\t\t}\n\t\tconsole.log(sum) // 15\n```\n\n- 总数（初始值/先前返回的值）\n- 项目值\n- 项目索引\n- 数组本身\n\n总数接受初始值\n\n```js\n\tlet arr = [1, 2, 3, 5, 4]\n\t\tlet sum = arr.reduce(myFc, 100)\n\n\t\tfunction myFc(totle, value) {\n\t\t\treturn totle + value\n\t\t}\n\t\tconsole.log(sum) //115\n```\n\n\n\nevery() 方法检查所有数组值是否通过测试\n\n例子：检查所有数组值是否大于 3\n\n```js\n\tlet arr = [1, 2, 3, 5, 4] \t\n\t\tlet result = arr.every(myFc)\n\n\t\tfunction myFc(value) {\n\t\t\treturn value > 3\n\t\t}\n\t\tconsole.log(result) // false\n```\n\n\n\nsome() 方法检查某些数组值是否通过了测试\n\n例子：检查某些数组值是否大于 2\n\n```\n\tlet arr = [1, 2, 3, 5, 4]\n\t\tlet result = arr.some(myFc)\n\n\t\tfunction myFc(value) {\n\t\t\treturn value > 2\n\t\t}\n\t\tconsole.log(result) // true\n```\n\n\n\nindexOf() 方法在数组中搜索元素值并返回其位置\n\n**注释：**第一个项目的位置是 0，第二个项目的位置是 1，以此类推。\n\n```js\n\tlet fruits = [\"Apple\", \"Orange\", \"Apple\", \"Mango\"];\n\t\tlet a = fruits.indexOf(\"Apple\");\n\t\tconsole.log(a) // 0\n```\n\n语法\n\n```js\narray.indexOf(item, start)\n```\n\n| *item*  | 必需。要检索的项目。                                         |\n| ------- | :----------------------------------------------------------- |\n| *start* | 可选。从哪里开始搜索。负值将从结尾开始的给定位置开始，并搜索到结尾 |\n\n如果未找到项目，Array.indexOf() 返回 -1。\n\n如果项目多次出现，则返回第一次出现的位置。\n\n\n\nArray.lastIndexOf() 与 Array.indexOf() 类似，但是从数组结尾开始搜索\n\n\n\nfind() 方法返回通过测试函数的第一个数组元素的值\n\n例子：查找（返回）大于 2 的第一个元素的值\n\n```js\nlet arr = [1, 2, 5, 4, 6]\n\t\tlet result = arr.find(myFc)\n\t\tfunction myFc(value, index, array) {\n\t\t\treturn value > 2\n\t\t}\n\t\tconsole.log(result)//5\n```\n\n请注意此函数接受 3 个参数：\n\n- 项目值\n- 项目索引\n- 数组本身\n\n\n\nfindIndex() 方法返回通过测试函数的第一个数组元素的索引\n\n例子：查找（返回）大于 2 的第一个元素索引\n\n```js\n\tlet arr = [1, 2, 5, 4, 6]\n\t\tlet result = arr.findIndex(myFc)\n\t\tfunction myFc(value, index, array) {\n\t\t\treturn value > 2\n\t\t}\n\t\tconsole.log(result) // 2\n```\n\n请注意此函数接受 3 个参数：\n\n- 项目值\n- 项目索引\n- 数组本身\n\n\n\n"},{"title":"前端面试","url":"/2021/12/20/前端面试/","content":"html篇\n1.行内元素有哪些，块级元素有哪些，行内块级元素有哪些？\n答：行内元素：a span em strong b i u lable br\n    块级元素: div p ul ol lo dl dt dd h1-h6 form table\n    行内块元素: img input textarea button\n    区别：行内元素可以多个标签存在一行 对宽高属性值不生效，完全靠内容撑开宽高，块级元素独占一行，对宽高属性值生效，行内块元素对宽高生效，并且可以多个标签存在一行\n\n2.display属性值区别\n答： display属性值： block inline inline-block\n\tblock: 前有换行符 设置宽高有效margin padding有效\n\tinline: 设置宽高无效  margin padding 在水平方向有效\n\tinline-block: 设置宽高有效 margin padding 无效\n\n3.input输入内容触发input事件\n\n4.什么是外边距重叠?重叠的结果是什么\n答：两个盒子或多个盒子相邻边界重合在一起形成一个单一边界，重叠结果会偏向高度较大者\n\n5.怪异盒子模型和标准盒子模型\n答：盒子模型：content+padding+border+margin\n\t标准盒子模型：width = content\n\t怪异盒子模型：width = content+padding+border\n\n6.display的none和visibility的hidden的区别\n答：display的隐藏后的元素不会占据任何空间，visibility隐藏的元素会占据空间。而且visibility具有继承性，会影响子元素\n\n7.localstorage和sessionstorage的区别：\n  localstorage会永远的保存数据，只有当手动去清除的时候才能删除数据，而sessionstorage当浏览器关闭时和用内部链接打开的浏览器时，数据才自动清除\n\n8.input的输入类型（type）有哪些？\n答：text password check radio button hidden submit file\n\n9.transition transform translate 的区别\n答：transform：主要用于元素2D或者3D转换，将元素rotate（旋转）、scale（缩放）、skew（扭曲）、translate（平移）\n    translate：控制元素移动，一个css变换函数\n    transition：css过渡属性 （property、duration（持续时间）、timing-function：ease、delay（延迟））\n\n10.split()和join()的区别\n答：split与join都是对字符或者字符串进行操作，split()用于分割字符串，返回值是一个数组，join()用于连接字符或者字符串，返回值是一个字符串（默认连接为,）\n\n11.typeof返回的数据类型有什么？\n答：nnusb  null number undefined string boolean object\n\n12.如何阻止事件冒泡？\n答：IE9: 调用stopPropagation()IE9之前：e.cancelBubble = true\n\n13.什么是闭包？\n答：在一个作用域可以访问另一个作用域的变量\n    清除闭包缓存 把外层函数调用之后设置为null进行销毁\n\n14.路由传值？\n答：query传递参数：通过url传值，不安全，有长度限制\n    params传递参数：通过js对象跳转过程中传值 只有使用name作为依据跳转才能用，更加安全，没有长度限制，缺点：页面刷新数据就没了\n\n15.JSON对象之间的转换\n答：JSON串转JS对象  JSON.parse()  JS对象转JSON串 JSON.stringify()"},{"title":"Vue.js中的过滤器使用","url":"/2021/04/13/Vue.js中的过滤器使用/","content":"<h2>Vue中的过滤器分为两种：局部过滤器和全局过滤器</h2>\n\n<h3>1、定义无参全局过滤器</h3>\n\n```javascript\n Vue.filter('msgFormat', function(msg) {    // msg 为固定的参数 即是你需要过滤的数据\n            return msg.replace(/单纯/g, 'xxx') // xxx 为全局单纯替换的东西\n       })\n```\n\n<h3>完整实例</h3>\n\n```html\n<div id=\"app\">\n            <p>{{ msg | msgFormat}}</p>\n        </div>\n```\n\n```javascript\n            // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat\n            Vue.filter('msgFormat', function(msg) {\n                // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则\n                return msg.replace(/单纯/g, 'xx')\n            })\n```\n\n<h3>定义有参全局过滤器</h3>\n\n```html\n <div id=\"app\">\n            <p>{{ msg | msgFormat('疯狂','--')}}</p>\n        </div>\n```\n\n```javascript\n            // 定义一个 Vue 全局的过滤器，名字叫做  msgFormat\n            Vue.filter('msgFormat', function(msg, arg, arg2) {\n                // 字符串的  replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则\n                return msg.replace(/单纯/g, arg+arg2)\n            })\n```\n\n<h3>局部过滤器</h3>\n\n局部过滤器的有参和无参的定义和使用方法与全局的过滤器一样。唯一的区别在于局部过滤器是定义在vue的实例中。其作用的区域也是vue实例【#app】控制的区域\n\n```javascript\n // 创建 Vue 实例，得到 ViewModel\n            var vm = new Vue({\n                el: '#app',\n                data: {\n                    msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人'\n                },\n                methods: {},\n                //定义私用局部过滤器。只能在当前 vue 对象中使用\n                filters: {\n                    // 定义私有过滤器 过滤器有两个条件 【过滤器名称 和 处理函数】\n                    // 过滤器调用的时候，采用的是就近原则 如果私有过滤器和全局过滤器一致 这时候优先调用私有过滤器\n                    dataFormat(msg) {\n                        return msg+'xxxxx';\n                    }\n                }\n            });\n```\n\n<font color=red face=\"黑体\">注意：</font>\n\n<font color=red face=\"黑体\">1、 当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！</font>\n\n<font color=red face=\"黑体\">2、 一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右</font>"},{"title":"JavaScript中var、let和constd 区别","url":"/2020/09/14/JavaScript中var、let和constd 区别/","content":"<h3>一、前言</h3>\n\n在ES6（ES2015）出现之前，JavaScript中声明变量只能通过var关键字，函数的声明是通过function关键字，而在ES6之后，声明的方式有var、let、const、function、class，本文主要讨论var、let、和const之间的区别\n\n<h3>二、var</h3>\n如果使用关键字var声明一个变量，那么这个变量就属于当前的函数作用域，如果声明是发生在任何函数外的顶层声明，那么这个变量就属于全局作用域。举例说明：\n\n```javascript\nvar a = 1;  //此处声明的变量a为去全局变量\nfunction foo (){\n    var a  = 2  //此处声明的变量a为函数foo的局部变量\n    console.log(a); //2\n}\nfoo();\nconsole.log(a); //1\n```\n\n如果在声明变量时，省略var的话，该变量就会变成全局变量，如全局作用域中存在该变量，就会更新其值。如：\n\n```javascript\nvar a = 1;  //此处声明的变量a为全局变量\nfunction foo(){\n    a = 2;  //此处的变量a也是全局变量\n    console.log(a)  //2\n}\nfoo();\nconsole.log(a)  //2\n```\n\n注意：var声明的变量存在提升（hoisting）。\n\n<h3>三、提升</h3>\n\n提升是指无论var出现在一个作用域的哪个位置，这个声明都属于当前的整个作用域，在其中到处都可以访问到。注意只有变量声明才会提升，对变量赋值并不会提升。如下例所示：\n\n```JavaScript\nconsole.log(a)  //undefined\nvar a = 1;\n```\n\n该代码跟下列代码是一样的逻辑：\n\n```JavaScript\nvar a;\nconsole.log(a); //undefined\na = 1;\n```\n\n而如果对未声明过的变量进行操作，就会报错\n\n```JavaScript\nconsole.log(b); //假设b未声明过，Uncaught ReferenceError: b is not defined\n```\n\n<h3>四、let</h3>\n\nlet声明的变量，具有如下几个特点：\n    1.let声明的变量具有块作用域的特征。\n    2.在同一个块级作用域，不能重复声明变量。\n    3.let声明的变量不存在变量提升，换一种说法，就是let声明存在暂时性死区（TDZ）。\n\n如下面几个例子所示\n\n```JavaScript\nlet a = 1;\nconsole.log(a); //1\nconsole.log(b); //Uncaught ReferenceError: b is not defined\nlet b = 2;\n```\n\n```JavaScript\nfunction foo(){\n    let a = 1;\n    let a = 2;  //Uncaught SyntaxError: Identifier 'a' has alrealy been declared\n}\n```\n\n以下是一个经典的关于var和let的一个例子：\n\n```JavaScript\nfor (var i = 0; i < 10; i++) {\n    setTimeout(function(){\n        console.log(i);\n    },100)\n}\n```\n\n则该代码运行后，就会在控制台打印出10个10.若修改为：\n\n```JavaScript\nfor (let i = 0; i < 10; i++) {\n    setTimeout(function(){\n        console.log(i);\n    },100)\n}\n```\n\n则该代码运行后，就会在控制台打印出0-9.\n\n<h3>五、const</h3>\n\nconst声明方式，除了具有let的上述特点外，其还具备一个特点，即const定义的变量，一旦定义后，就不能修改，即const声明的为常量。\n\n例如：\n\n```JavaScript\nconst a = 1;\nconsole.log(a); //1\na = 2;\nconsole.log(a); //Uncaught TypeError: Assignment to constant variable.\n```\n\n但是，并不是说const声明的变量其内部内容不可变，如：\n\n```JavaScript\nconst obj = {\n    a: 1,\n    b: 2\n}\nconsole.log(obj.a); //1\nobj.a = 3;\nconsole.log(obj.a); //3\n```\n\n所以准确的说，是const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。\n\n<h3>六、总结</h3>\n    1.var声明的变量属于函数作用域，let和const声明的变量属于块级作用域；\n    2.var存在变量提升现象，而let和const没有此类现象；\n    3.var变量可以重复声明，而在同一个块级作用域，let变量不能重新声明，const变量不能修改。\n"},{"title":"JavaScript深拷贝与浅拷贝的区别","url":"/2020/09/06/JavaScript深拷贝与浅拷贝的区别/","content":"<h3>原因及区别</h3>\n\n我们都知道js中有两种数据类型,一种是基本数据类型,一种是引用数据类型,基本数据类型是按值访问的,即在操作基本类型的变量时,是直接修改变量的值,而引用数据类型的值是按引用访问的,什么叫按引用访问的呢?js的引用类型,也叫对象类型,是保存在内存中的,而在js中又无法直接操作内存中的对象,实际上操作的是对象的引用,因此在引用类型变量在进行复制操作时,并不是对对象值的直接复制,而是将对象的引用复制给了另一个变量,实际上变量指向的是同一个内存地址中对象的值,因此只要改变其中一个对象变量的值另外一个就会一起改变,这就是我们常说的浅拷贝。而在深拷贝中,会开辟一个新的内存地址用来存放新对象的值,两个对象对应两个不同的内存地址 ,修改一个对象并不会对另外一个对象产生影响。接下来就让我们更细致的探究js中的深浅拷贝。\n\n<h3>浅拷贝</h3>\n\n实现浅拷贝的方法有多种,让我们先来看看js中提供的几个自带方法实现浅拷贝的的例子:\n\nObject.assign()方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。注意:Object.assign()拷贝的是属性值,假如源对象的属性值是一个指向对象的引用,它也只拷贝那个引用值,来看个例子:\n\n```javascript\nvar a = {\n    a: 'old',\n    b: {\n     c: 'old'\n    }\n   }\n   var b = Object.assign({}, a)\n   b.a = 'new'\n   b.b.c = 'new'\n   console.log(a) // { a: 'old', b: { c: 'new' } }\n   console.log(b) // { a: 'new', b: { c: 'new' } }\n```\n\n如上面例子,当拷贝的源对象的属性值是一个对象时,拷贝的只是对象的引用值,因此当修改属性值的时候两个对象的属性值都会发生更新\n\nObject.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n\n```javascript\nconst target = { a: 1, b: 2 };\nconst source = { b: 4, c: 5 };\n\nconst returnedTarget = Object.assign(target, source);\n\nconsole.log(target);\n// expected output: Object { a: 1, b: 4, c: 5 }\n\nconsole.log(returnedTarget);\n// expected output: Object { a: 1, b: 4, c: 5 }\n\n```\n\nArray.prototype.slice()方法提取并返回一个新的数组,如果源数组中的元素是个对象的引用,slice会拷贝这个对象的引用到新的数组,来看个例子:\n\n```javascript\nvar arr = ['a', 'b',\n   {d: 'old'}]\n   var arr1 = arr.slice(1)\n   // slice() 方法返回一个新的数组对象，\n   // 这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。\n   console.log(arr1);\n   arr1[1].d = 'new';\n   console.log(arr[2].d) // new\n```\n\n如上例所示,但源数组中的元素是对象引用时,slice拷贝的是这个对象的引用,因此当修改其中一个的值时,两个数组中的值都会发生改变\n\n除了上述js中自带方法实现的浅拷贝外,我们自己如何简单实现一个浅拷贝呢?来看个例子:\n\n```javascript\nvar obj1 = {\n    name: 'zs',\n    age: 18,\n    sex: '男',\n    dog: {\n     name: '金毛',\n     age: 2,\n     yellow: '黄色'\n    }\n   }\n   var obj2 = {};\n   // 封装函数 - 把o1的成员复制给o2\n\n   // 浅拷贝-只是复制了对象的层\n   function copy(o1, o2) {\n    for (var key in o1) {\n     o2[key] = o1[key];\n    }\n   }\n   copy(obj1, obj2);\n   // 修改obj1中的成员\n   obj1.name = 'xxx';\n   obj1.dog.name = '阿拉斯加';\n   console.dir(obj2);\n```\n\n```javascript\n// 深拷贝-多层复制\n   var obj1 = {\n    name: 'zs',\n    age: 18,\n    sex: '男',\n dog: {\n     name: '柴犬',\n     age: 2\n    },\n    friends: ['ls', 'ww']\n   };\n\n   // 深拷贝 把o1的成员拷贝给o2\n   function deepCopy(o1, o2) {\n    for (var key in o1) {\n     // key 相当于一个字符串 获取对象o1的属性 从o1.[0]开始\n     // 获取属性对应的值\n     var item = o1[key];\n\n     // 如果item是对象呢?\n     // var o = {}\n     if (item instanceof Object) {\n      // var o = {};\n      o2[key] = {};\n      deepCopy(item, o2[key]);\n     } else if (item instanceof Array) {\n      // 如果item是数组呢?\n      // var arr = [];\n      o2[key] = []\n      deepCopy(item, o2[key]);\n     } else {\n      // 如果是简单类型\n      o2[key] = o1[key];\n     }\n    }\n   }\n\n   var obj2 = {};\n\n   deepCopy(obj1, obj2);\n\n   // 修改obj1中的成员  是否会影响obj2?\n   obj1.dog.name = 'xxx';\n   obj1.friends[0] = 'xx';\n\n   console.dir(obj2);\n                      /*age: 18\n                      dog: {name: \"柴犬\", age: 2}\n                      friends: {0: \"ls\", 1: \"ww\"}\n                      name: \"zs\"\n                      sex: \"男\" */\n   console.dir(obj1);\n                      /* age: 18\n                      dog: {name: \"xxx\", age: 2}\n                      friends: (2) [\"xx\", \"ww\"]\n                      name: \"zs\"\n                      sex: \"男\"*/\n```\n\n通过对需要拷贝的对象的属性进行递归遍历,如果对象的属性不是基本类型时,就继续递归,知道遍历到对象属性为基本类型,然后将属性和属性值赋给新对象。\n<h3>总结</h3>\n\n以上对js深拷贝和浅拷贝做了简单的介绍,在深拷贝的实现上也只介绍了最简单的实现形式,并未考虑复杂情况以及相应优化,想要对深拷贝有更深入的了解,需要大家花时间去深入研究,或者可以关注我后续文章的动态。\n"},{"title":"querySelector和getElementById方法的区别","url":"/2020/06/04/querySelector和getElementById方法的区别/","content":"发现querySelector()是用于接收一个CSS选择符，返回与该模式匹配的第一个元素；querySelectorAll()用于选择匹配到的所有元素。\n完了看到这我就有点懵，所以这俩有什么用呢？不是已经有了getElementById()和getElementsByTagName()了吗，这两个新添加的选择符API意义何在？\n查了《高程》并没有找到答案，最后还是百度了一堆资料，终于算是搞懂了。\n简单的说，query选择符选出来的元素及元素数组是静态的，而getElement这种方法选出的元素是动态的。\n什么叫静态的？意思是指选出的所有元素的数组，不会随着文档操作而改变。\n用querySelector操作元素示例如下：\nHTML代码：\n![alt](/images/js.image3.png)\n\n![alt](/images/js.image4.png)\n\n反观getElement方法\n\n![alt](/images/js.image5.png)\n所以我们现在应该可以很直观的分别出两者的区别，当然本身两种方法还有兼容性方面的区别。\n另外这两种方法都不能查找伪类元素。\n\n补充：getAttribute() 返回元素上一个指定的属性值。如果指定的属性不存在，则返回  null 或 \"\";"},{"title":"call、apply、bind的用法","url":"/2020/06/02/call、apply、bind的用法/","content":"call：call 是函数的正常调用方式，并指定上下文 this。\napply：apply 的作用和 call 一样，只是在调用的时候，传参数的方式不同。区别是 apply 接受的是数组参数，call 接受的是连续参数。如下代码：\n![alt](/images/js.image1.png)\n\nbind：bind 接受的参数跟 call 一致，只是 bind 不会立即调用，它会生成一个新的函数，你想什么时候调就什么时候调。如下代码：\n\n![alt](/images/js.image2.png)"},{"title":"grid布局","url":"/2020/05/22/grid布局/","content":"一、概述\n_______________________________________________________________________________________________________________________\n网格布局（Grid）是最强大的 CSS 布局方案。\n\n它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。\n![grid布局界面](/images/grid1.png)\n上图这样的布局，就是 Grid 布局的拿手好戏。\n\nGrid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。\n\nFlex 布局是轴线布局，只能指定\"项目\"针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成\"行\"和\"列\"，产生单元格，然后指定\"项目所在\"的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。\n\n二、基本概念\n_______________________________________________________________________________________________________________________\n学习 Grid 布局之前，需要了解一些基本概念。\n\n2.1 容器和项目\n\n采用网格布局的区域，称为\"容器\"（container）。容器内部采用网格定位的子元素，称为\"项目\"（item）。\n![alt](/images/grid2.png)\n\n上面代码中，最外层的div元素就是容器，内层的三个div元素就是项目。\n\n注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的p元素就不是项目。Grid 布局只对项目生效。\n\n2.2 行和列\n\n容器里面的水平区域称为\"行\"（row），垂直区域称为\"列\"（column）。\n![alt](/images/grid3.png)\n上图中，水平的深色区域就是\"行\"，垂直的深色区域就是\"列\"。\n2.3 单元格\n\n行和列的交叉区域，称为\"单元格\"（cell）。\n\n正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。\n2.4 网格线\n\n划分网格的线，称为\"网格线\"（grid line）。水平网格线划分出行，垂直网格线划分出列。\n\n正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/1_bg2019032503.png\" />\n上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。\n\n三、容器属性\n_______________________________________________________________________________________________________________________\nGrid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。\n\n3.1 display 属性\ndisplay: grid指定一个容器采用网格布局。\n![alt](/images/grid5.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032504.png\" />\n上图是display: grid的<a href=\"https://jsbin.com/guvivum/edit?html,css,output\">效果</a>\n默认情况下，容器元素都是块级元素，但也可以设成行内元素。\n\n![alt](/images/grid7.png)\n上面代码指定div是一个行内元素，该元素内部采用网格布局。\n\n![alt](/images/grid8.png)\n上图是display: inline-grid的<a href=\"https://jsbin.com/qatitav/edit?html,css,output\">效果</a>\n\n注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。\n\n3.2\ngrid-template-columns 属性，\ngrid-template-rows 属性\n\n容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。\n![alt](/images/grid9.png)\n<a href=\"https://jsbin.com/qatitav/edit?html,css,output\">上面代码</a>指定了一个三行三列的网格，列宽和行高都是100px。\n![alt](/images/grid10.png)\n除了使用绝对单位，也可以使用百分比。\n\n![alt](/images/grid11.png)\n\n<strong>（1）repeat()</strong>\n\n有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。\n![alt](/images/grid12.png)\nrepeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。\n\nrepeat()重复某种模式也是可以的。\n![alt](/images/grid13.png)\n\n<a href=\"https://jsbin.com/cokohu/edit?css,output\">上面代码</a>定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032507.png\" alt=\"\" >\n\n<strong>（2）auto-fill 关键字</strong>\n\n有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。\n![alt](/images/grid14.png)\n<a href=\"https://jsbin.com/himoku/edit?css,output\">上面代码</a>表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032508.png\" alt=\"\" >\n\n<strong>（3）fr 关键字</strong>\n\n为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为\"片段\"）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。\n![alt](/images/grid15.png)\n<a href=\"https://jsbin.com/hadexek/edit?html,css,output\">上面代码</a>表示两个相同宽度的列。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/1_bg2019032509.png\" alt=\"\" >\nfr可以与绝对长度的单位结合使用，这时会非常方便。\n![alt](/images/grid16.png)\n<a href=\"https://jsbin.com/remowec/edit?html,css,output\">上面代码</a>表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032510.png\" alt=\"\" >\n<strong>（4）minmax()</strong>\n\nminmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。\n![alt](/images/grid17.png)\n上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。\n\n<strong>（5）auto 关键字</strong>\n\nauto关键字表示由浏览器自己决定长度。\n![alt](/images/grid18.png)\n\n上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。\n\n<strong>（6）网格线的名称</strong>\n\ngrid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。\n![alt](/images/grid19.png)\n\n上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。\n\n网格布局允许同一根线有多个名字，比如[fifth-line row-5]。\n\n<strong>（7）布局实例</strong>\n\ngrid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。\n![alt](/images/grid20.png)\n上面代码将左边栏设为70%，右边栏设为30%。\n传统的十二网格布局，写起来也很容易。\n\n![alt](/images/grid21.png)\n\n3.3\ngrid-row-gap 属性，\ngrid-column-gap 属性，\ngrid-gap 属性\n\ngrid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。\n![alt](/images/grid22.png)\n<a href=\"https://jsbin.com/mezufab/edit?css,output\">上面代码</a>中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032511.png\" alt=\"\" >\ngrid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。\n\n![alt](/images/grid23.png)\n因此，上面一段 CSS 代码等同于下面的代码。\n\n![alt](/images/grid24.png)\n如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。\n\n根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。\n\n3.4 grid-template-areas 属性\n\n网格布局允许指定\"区域\"（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。\n![alt](/images/grid25.png)\n上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。\n\n多个单元格合并成一个区域的写法如下。\n![alt](/images/grid26.png)\n\n上面代码将9个单元格分成a、b、c三个区域。\n\n下面是一个布局实例。\n![alt](/images/grid27.png)\n\n上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。\n\n如果某些区域不需要利用，则使用\"点\"（.）表示。\n![alt](/images/grid28.png)\n\n上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。\n\n注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。\n\n比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。\n\n3.5 grid-auto-flow 属性\n\n划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是\"先行后列\"，即先填满第一行，再开始放入第二行，即下图数字的顺序\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032506.png\" alt=\"\" >\n这个顺序由grid-auto-flow属性决定，默认值是row，即\"先行后列\"。也可以将它设成column，变成\"先列后行\"。\n\n![alt](/images/grid29.png)\n<a href=\"https://jsbin.com/xutokec/edit?css,output\">上面代码</a>设置了column以后，放置顺序就变成了下图。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032512.png\" alt=\"\" >\n\ngrid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。\n<a href=\"https://jsbin.com/wapejok/edit?css,output\">下面的例子</a>让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row情况下，会产生下面这样的布局。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032513.png\" alt=\"\">\n上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。\n\n现在修改设置，设为row dense，表示\"先行后列\"，并且尽可能紧密填满，尽量不出现空格。\n\n![alt](/images/grid30.png)\n<a href=\"https://jsbin.com/helewuy/edit?css,output\">上面代码</a>的效果如下。\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032514.png\" alt=\"\" >\n上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。\n\n如果将设置改为column dense，表示\"先列后行\"，并且尽量填满空格。\n![alt](/images/grid31.png)\n<a href=\"https://jsbin.com/pupoduc/1/edit?html,css,output\">上面代码</a>的效果如下。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032515.png\" alt=\"\">\n上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。\n\n3.6\njustify-items 属性，\nalign-items 属性，\nplace-items 属性\n\njustify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。\n![alt](/images/grid32.png)\n这两个属性的写法完全相同，都可以取下面这些值。\n![alt](/images/grid33.png)\n![alt](/images/grid34.png)\n<a href=\"https://jsbin.com/gijeqej/edit?css,output\">上面代码</a>表示，单元格的内容左对齐，效果如下图。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032516.png\" alt=\"\" >\n![alt](/images/grid35.png)\n<a href=\"https://jsbin.com/tecawur/edit?css,output\">上面代码</a>表示，单元格的内容头部对齐，效果如下图。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032517.png\" alt=\"\" >\nplace-items属性是align-items属性和justify-items属性的合并简写形式。\n![alt](/images/grid36.png)\n\n下面是一个例子。\n![alt](/images/grid37.png)\n如果省略第二个值，则浏览器认为与第一个值相等。\n\n3.7\njustify-content 属性，\nalign-content 属性，\nplace-content 属性\n\njustify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。\n![alt](/images/grid38.png)\n这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。）\n![alt](/images/grid39.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032519.png\" alt=\"\">\n![alt](/images/grid40.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032518.png\" alt=\"\" >\n![alt](/images/grid41.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032520.png\" alt=\"\" >\n![alt](/images/grid42.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032521.png\" alt=\"\" >\n![alt](/images/grid43.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032522.png\" alt=\"\" >\n![alt](/images/grid44.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032523.png\" alt=\"\" >\n![alt](/images/grid45.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032524.png\" alt=\"\" >\nplace-content属性是align-content属性和justify-content属性的合并简写形式。\n![alt](/images/grid46.png)\n下面是一个例子。\n![alt](/images/grid47.png)\n如果省略第二个值，浏览器就会假定第二个值等于第一个值。\n\n3.8\ngrid-auto-columns 属性，\ngrid-auto-rows 属性\n\n有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。\n\ngrid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。\n\n<a href=\"https://jsbin.com/sayuric/edit?css,output\">下面例子</a>里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。\n\n![alt](/images/grid48.png)\n上面代码指定新增的行高统一为50px（原始的行高为100px）。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032525.png\" alt=\"\" >\n\n3.9\ngrid-template 属性，\ngrid 属性\n\ngrid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。\n\ngrid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。\n\n从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。\n\n\n四、项目属性\n_______________________________________________________________________________________________________________________\n下面这些属性定义在项目上面。\n\n4.1\ngrid-column-start 属性，\ngrid-column-end 属性，\ngrid-row-start 属性，\ngrid-row-end 属性\n\n项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。\n![alt](/images/grid49.png)\n![alt](/images/grid50.png)\n<a href=\"https://jsbin.com/yukobuf/edit?css,output\">上面代码</a>指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032526.png\" alt=\"\">\n上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。\n\n除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会\"先行后列\"进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。\n\n<a href=\"https://jsbin.com/nagobey/edit?html,css,output\">下面例子</a>是指定四个边框位置的效果。\n\n![alt](/images/grid51.png)\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032527.png\" alt=\"\" >\n\n这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。\n![alt](/images/grid52.png)\n上面代码中，左边框和右边框的位置，都指定为网格线的名字。\n\n这四个属性的值还可以使用span关键字，表示\"跨越\"，即左右边框（上下边框）之间跨越多少个网格。\n\n![alt](/images/grid53.png)\n<a href=\"https://jsbin.com/hehumay/edit?html,css,output\">上面代码</a>表示，1号项目的左边框距离右边框跨越2个网格。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032528.png\" alt=\"\" >\n这与<a href=\"https://jsbin.com/mujihib/edit?html,css,output\">下面的代码</a>效果完全一样。\n![alt](/images/grid54.png)\n\n使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。\n\n4.2\ngrid-column 属性，\ngrid-row 属性\n\ngrid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。\n![alt](/images/grid55.png)\n下面是一个例子。\n![alt](/images/grid56.png)\n上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。\n\n这两个属性之中，也可以使用span关键字，表示跨越多少个网格。\n\n![alt](/images/grid57.png)\n<a href=\"https://jsbin.com/volugow/edit?html,css,output\">上面代码</a>项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032529.png\" alt=\"\" >\n斜杠以及后面的部分可以省略，默认跨越一个网格。\n\n![alt](/images/grid58.png)\n上面代码中，项目item-1占据左上角第一个网格。\n\n4.3 grid-area 属性\n\ngrid-area属性指定项目放在哪一个区域。\n\n![alt](/images/grid59.png)\n<a href=\"https://jsbin.com/qokexob/edit?css,output\">上面代码</a>中，1号项目位于e区域，效果如下图。\n\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032530.png\" alt=\"\" >\ngrid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。\n\n![alt](/images/grid60.png)\n下面是一个<a href=\"https://jsbin.com/duyafez/edit?css,output\">例子</a>\n![alt](/images/grid61.png)\n\n4.4\njustify-self 属性，\nalign-self 属性，\nplace-self 属性\n\njustify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。\n\nalign-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。\n![alt](/images/grid62.png)\n这两个属性都可以取下面四个值。\n![alt](/images/grid63.png)\n下面是justify-self: start的例子。\n![alt](/images/grid64.png)\n<img src=\"https://www.wangbase.com/blogimg/asset/201903/bg2019032532.png\" alt=\"\" >\nplace-self属性是align-self属性和justify-self属性的合并简写形式。\n\n![alt](/images/grid65.png)\n下面是一个例子。\n![alt](/images/grid66.png)\n如果省略第二个值，place-self属性会认为这两个值相等。\n\n总结：相对于flex一维布局 grid二维布局更加的全面 使用的范围更加的广 但grid布局的浏览器兼容性需要处理，需要版本较高的浏览器。（建议使用IE9以上，谷歌、火狐等浏览器）"},{"title":"PowerShell因为在此系统中禁止执行脚本问题的解决方法","url":"/2020/05/22/PowerShell因为在此系统中禁止执行脚本问题的解决方法/","content":"首次在计算机上启动 Windows PowerShell 时，现用执行策略很可能是 Restricted（默认设置）。\n\nRestricted 执行策略是不允许任何脚本运行。\n\nAllSigned 和 RemoteSigned 执行策略可防止 Windows PowerShell 运行没有数字签名的脚本。\n\n那么如何运行所选未签名脚本（即使在执行策略为 RemoteSigned 的情况下），如何对脚本进行签名以便您自己使用。\n\n有关 Windows PowerShell 执行策略的详细信息，请输入: about_Execution_Policy\n若要了解计算机上的现用执行策略，在PowerShell中输入：get-executionpolicy\n若要在本地计算机上运行您编写的未签名脚本和来自其他用户的签名脚本，请使用以下命令将计算机上的 执行策略更改为 RemoteSigned：set-executionpolicy remotesigne\n所以只要运行上述命令就可以了。\n有关详细信息，请输入Set-ExecutionPolicy\n"},{"title":"first","url":"/2020/05/22/first/","content":"title: this is my first blog\n"},{"title":"Hello World","url":"/2020/05/22/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]